# frozen_string_literal: true

require 'logger'
require 'optparse'

require 'command_line_boss/help_option'
require 'command_line_boss/logger_options'
require 'command_line_boss/version'

# Command line interface parser based on OptionsParser
#
# @api public
#
class CommandLineBoss
  # Create a new command line parser
  #
  # @example
  #   parser = CommandLineParser.new
  #
  # @param program_name [String] the name of the program to report in the usage line
  #
  #   The program name is used in the usage line when the --help option is given.
  #   This is given as an optional argument so that it can be overridden in tests.
  #
  def initialize(program_name: $PROGRAM_NAME)
    @program_name = program_name
    @parser = OptionParser.new.tap { |p| p.set_program_name(program_name) }
    @error_messages = []
    set_defaults if private_methods.include?(:set_defaults)
    define_options
  end

  # Parse the command line arguments and return self
  #
  # The caller will have to check the {#failed?} to see if there were any errors.
  #
  # If there were errors, {#error_messages} will contain the error messages.
  #
  # @example
  #   parser = CommandLineParser.new.call(ARGV)
  #
  # @param args [Array<String>] the command line arguments
  #
  # @return [CommandLineParser] returns self
  #
  def parse(args)
    @args = args.dup
    parse_options
    parse_arguments
    validate if @error_messages.empty?
    self
  end

  # Parse the command line arguments and return self
  #
  # If there were any errors parsing the command line arguments, this method
  # will output the error messages to stderr and exit the program with a non-zero
  # status code.
  #
  # @example
  #   parser = CommandLineParser.new.parse!(ARGV)
  #
  # @param args [Array<String>] the command line arguments
  #
  # @raise [SystemExit] if the command line arguments are invalid
  #
  # @return [CommandLineParser] returns self
  #
  def parse!(args)
    parse(args)

    if failed?
      warn error_messages.join("\n")
      exit 1
    end

    self
  end

  # The name of the program to report in the usage line
  #
  #   The program name is used in the usage line when the --help option is given.
  #   This is given as an optional argument so that it can be overridden in tests.
  #
  # @example
  #   options.program_name #=> 'sync_paranoids_milestones'
  #
  # @return [String]
  #
  attr_reader :program_name

  # The error messages generated by the validation methods
  #
  # @example
  #   options.error_messages #=> ["ERROR: The sheet 'Sheet1' was given more than once"]
  #
  # @return [Array<String>]
  #
  def error_messages = @error_messages.dup.freeze

  # true if the parser encountered no errors
  #
  #
  # @example
  #   options.succeeded? #=> true
  #
  # @return [Boolean]
  #
  def succeeded? = @error_messages.empty?

  # true if the parser encountered errors
  #
  # @example
  #   options.failed? #=> false
  #
  # @return [Boolean]
  #
  def failed? = !succeeded?

  VALIDATION_METHOD_REGEXP = /^validate_(.+)$/

  DEFINITION_METHOD_REGEXP = /^define_(.+)_option$/

  private

  # This is how you should add an error message to the error_messages array
  #
  # @example
  #   add_error_message("The sheet 'Sheet1' was given more than once")
  #   error_messages #=> ["ERROR: The sheet 'Sheet1' was given more than once"]
  #
  # @param message [String] the error message to add
  #
  # @return [void]
  #
  # @api private
  #
  def add_error_message(message)
    @error_messages << "ERROR: #{message}"
  end

  # Ensure that any extra args are valid
  #
  # This method is expected to add a message to {add_error} if there are
  # any unexpected arguments.
  #
  # For this command line, there should be no extra arguments.
  #
  # @return [void]
  #
  # @api private
  #
  def validate_remaining_args
    return if args.empty?

    add_error_message("Unexpected arguments: #{args.join(' ')}")
  end

  # The parse to use to parse the command line arguments
  #
  # @return [OptionParser]
  #
  # @api private
  #
  attr_reader :parser

  # The command line args passed to the parser
  #
  # The parser will remove options and their arguments from this array
  # as it parses them.
  #
  # After all options are parsed, this array will contain only the
  # remaining arguments.
  #
  # @return [Array<String>]
  #
  # @api private
  #
  attr_reader :args

  # Parse the command line arguments using the OptionParser
  #
  # The OptionParser will remove options and their arguments from the
  # `args` array as it parses them. After all options are parsed, `args`
  # will contain only the remaining arguments.
  #
  # @raise [SystemExit] if the command line arguments are invalid
  #
  # @return [void]
  #
  # @api private
  #
  def parse_options
    parser.parse!(args)
  rescue OptionParser::ParseError => e
    add_error_message(e.message)
  end

  # Parse the arguments that remain after parsing options
  #
  # This method is expected to be overridden by subclasses to parse the
  # remaining arguments. {args} will contain the remaining arguments. This
  # method should remove any arguments it processes from {args}.
  #
  # @return [void]
  #
  # @api private
  #
  def parse_arguments; end

  # Validate the command line options and remaining arguments
  #
  # Calls all validation methods defined by this class. Validation
  # methods are private methods that start with `validate_`.
  #
  # If validation fails, a validation method is expected to output an error
  # messages using `warn` and exit the program with a non-zero status code.
  #
  # @return [void]
  #
  # @api private
  #
  def validate
    private_methods.select { |m| m.to_s.match?(VALIDATION_METHOD_REGEXP) }.each { |m| send(m) }
  end

  # Set the default values for the command line options
  #
  # @return [void]
  #
  # @api private
  #
  # def set_defaults; end

  # Define the command line options
  #
  # @return [void]
  #
  # @api private
  #
  def define_options
    parser.separator 'Options:'
    private_methods.select { |m| m.to_s.match?(DEFINITION_METHOD_REGEXP) }.each { |m| send(m) }
    parser.separator ''
  end
end
